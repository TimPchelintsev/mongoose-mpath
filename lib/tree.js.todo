schema.methods.getChildrenRecursive = function getChildrenRecursive(conditions, fields, options, callback) {
  conditions = conditions || {};
  fields     = fields || null;
  options    = options || {};

  if (conditions['$query']) {
    conditions['$query']['path'] = {$regex: '^' + this.path + pathSeparatorRegex};
  }
  else {
    conditions['path'] = {$regex: '^' + this.path + pathSeparatorRegex};
  }

  return this.model(this.constructor.modelName).find(conditions, fields, options, callback);
};

schema.statics.getChildrenTree = function getChildrenTree(root, args, next) {
  if ('function' === typeof(root)) {
    next = root;
    root = null;
    args = {};
  }
  else if ('function' === typeof(args)) {
    next = args;

    if ('model' in root) {
      args = {};
    }
    else {
      args = root;
      root = null;
    }
  }

  var filters            = args.filters || {};
  var fields             = args.fields || null;
  var options            = args.options || {};
  var minLevel           = args.minLevel || 1;
  var recursive          = args.recursive !== undefined
      ? args.recursive
      : true;
  var allowEmptyChildren = args.allowEmptyChildren !== undefined
      ? args.allowEmptyChildren
      : true;

  if (!next) {
    throw new Error('no callback defined when calling getChildrenTree');
  }

  // filters: Add recursive path filter or not
  if (recursive) {
    if (root) {
      filters.path = {$regex: '^' + root.path + pathSeparatorRegex};
    }

    if (filters.parent === null) {
      delete filters.parent;
    }
  }
  else {
    if (root) {
      filters.parent = root._id;
    }
    else {
      filters.parent = null;
    }
  }

  // fields: Add path and parent in the result if not already specified
  if (fields) {
    if (fields instanceof Object) {
      if (!fields.hasOwnProperty('path')) {
        fields['path'] = 1;
      }
      if (!fields.hasOwnProperty('parent')) {
        fields['parent'] = 1;
      }
    }
    else {
      if (!fields.match(/path/)) {
        fields += ' path';
      }
      if (!fields.match(/parent/)) {
        fields += ' parent';
      }
    }
  }

  // options:sort , path sort is mandatory
  if (!options.sort) {
    options.sort = {};
  }
  options.sort.path = 1;

  if (options.lean === null) {
    options.lean = !wrapChildrenTree;
  }

  return this.find(filters, fields, options, function(err, results) {
    if (err) {
      return next(err);
    }

    var getLevel = function(path) {
      return path ? path.split(pathSeparator).length : 0;
    };

    var createChildren = function createChildren(arr, node, level) {

      if (level === minLevel) {
        if (allowEmptyChildren) {
          node.children = [];
        }
        return arr.push(node);
      }

      var nextIndex = arr.length - 1;
      var myNode    = arr[nextIndex];

      if (!myNode) {
        return [];
      }
      else {
        createChildren(myNode.children, node, level - 1);
      }
    };

    var finalResults = [];
    var rootLevel    = 1;

    if (root) {
      rootLevel = getLevel(root.path) + 1;
    }

    if (minLevel < rootLevel) {
      minLevel = rootLevel;
    }

    for (var r in results) {
      var level = getLevel(results[r].path);
      createChildren(finalResults, results[r], level);
    }

    next(err, finalResults);
  });
};

schema.methods.getChildrenTree = function(args, next) {
  this.constructor.getChildrenTree(this, args, next);
};
